#!/usr/bin/env ruby

# TODO: Not needed after bundled as gem
gem 'liquid'
gem 'guard'
require 'gli'

$LOAD_PATH << File.expand_path('../lib', File.dirname(__FILE__))
require 'json'

require 'edicy/dtk'
require 'edicy/dtk/guard'
require 'edicy/dtk/renderer'
require 'edicy/dtk/filemanager'
require 'edicy_api'

include GLI::App

program_desc 'A tool to fetch and update Edicy design components'

version Edicy::Dtk::VERSION

verbose_args = [:verbose, { negatable: false, default_value: false, desc: 'Show additional information while running' }]
silent_args = [:silent, { default_value: false, negatable: false, desc: 'Hide all information text while running' }]
hostname_args = [:h, :host, :hostname, { desc: 'Provide a hostname', arg_name: :HOST }]
api_token_args = [:t, :token, :api_token, { desc: 'Provide an API token', arg_name: :API_TOKEN }]

switch *verbose_args
switch *silent_args

flag *hostname_args
flag *api_token_args

desc 'Initializes the local folder structure and files for a site'
long_desc "The init command takes a hostname and an api token
          as arguments, fetches the structure of the site and
          recreates it locally in the same folder the command
          was evoked in.\n
          If the hostname and/or api-token aren't provided via command-line
          arguments, the tool looks for a .edicy file in the current working
          directory that has those. See the readme for more information
          (http://github.com/Edicy/edicy-dtk)"
command :init do |c|
  c.switch *verbose_args
  c.switch *silent_args
  c.flag *hostname_args
  c.flag *api_token_args
  c.action do |global_options, options, args|
    @filemanager.copy_site_json
    @filemanager.create_folders
    @filemanager.create_files
  end

  c.command :new do |n|
    n.action do |n|
      @filemanager.copy_site_json
      @filemanager.fetch_boilerplate
    end
  end
end

desc 'Looks for missing files and folders'
command :check do |c|
  c.switch *verbose_args
  c.switch *silent_args
  c.flag *hostname_args
  c.flag *api_token_args
  c.action do |global_options, options, args|
    @filemanager.check
  end
end

desc 'Fetches the layout and layout asset files for the given site'
long_desc 'If no arguments are provided, the \'pull\' command fetches all
          layout files and layout assets and (re-)generates a manifest file.
          If filenames are provided, it fetches only those and updates the
          manifest with only those files. The provided names can be either
          filenames or layout/component titles.'
command :pull do |c|
  c.switch *verbose_args
  c.switch *silent_args
  c.flag *hostname_args
  c.flag *api_token_args
  c.action do |global_options, options, args|
    if args.length
      @filemanager.pull_files(args)
      @filemanager.generate_local_manifest
    else
      @filemanager.create_folders
      @filemanager.create_files
      @filemanager.generate_remote_manifest
    end
  end
end

desc 'Updates remote files with local changes'
command :push do |c|
  c.switch *verbose_args
  c.switch *silent_args
  c.flag *hostname_args
  c.flag *api_token_args
  c.action do |global_options, options, args|
    @filemanager.upload_files args
  end
end

desc "Generates a manifest.json file from the site's layout and asset files"
command :manifest do |c|
  c.switch *verbose_args
  c.switch *silent_args
  c.flag *hostname_args
  c.flag *api_token_args
  c.switch(
    [:r, :remote],
    default_value: false,
    desc: 'generate manifest from remote files'
  )
  c.action do |global_options, options, args|
    if options.fetch(:remote, @config[:remote])
      @filemanager.generate_remote_manifest
    else
      @filemanager.generate_local_manifest
    end
  end
end

desc 'Watches for file changes in the current directory'
command :watch do |c|
  c.switch *verbose_args
  c.switch *silent_args
  c.flag *hostname_args
  c.flag *api_token_args
  c.switch(
    [:e, :editmode],
    negatable: false,
    desc: "Specify if editmode should be considered \
          enabled for the purpose of rendering (default: false)"
  )
  c.action do |global_options, options, args|
    output_folder = args.first || 'html'
    @renderer = Edicy::Dtk::Renderer.new(Dir.pwd, output_folder)
    @renderer.editmode = options.fetch(:editmode) || @editmode

    Edicy::Dtk::Guuard.new(@renderer, @filemanager).run
    sleep 0.5 while ::Guard.running
  end
end

desc 'Renders all pages into static .html files that are usable locally'
arg_name 'Describe arguments to build here'
command :build do |c|
  c.switch *verbose_args
  c.switch *silent_args
  c.flag *hostname_args
  c.flag *api_token_args
  c.switch(
    [:e, :editmode],
    negatable: false,
    desc: 'Specify if editmode should be considered \
    enabled for the purpose of rendering (default: false)'
  )
  c.action do |global_options, options, args|
    output_folder = args.first || 'html'
    @renderer = Edicy::Dtk::Renderer.new(Dir.pwd, output_folder)
    @renderer.editmode = options.fetch(:editmode) || @editmode
    @renderer.render_all
  end
end

pre do |global, command, options, args|
  @config = Edicy::Dtk.read_config '.edicy'
  @editmode = @config[:editmode]

  silent = global.fetch(:silent, false) || options.fetch(:silent, false)
  verbose = global.fetch(:verbose, false) || options.fetch(:verbose, false)

  unless ([:watch, :build, :new].include? command.name)
    host = global.fetch(:host) || options.fetch(:host) || @config[:host]
    api_token = global.fetch(:token) || options.fetch(:token) || @config[:api_token]

    if host.nil?
      fail 'Hostname not found from arguments nor from .edicy file'.red
    end

    if api_token.nil?
      fail 'API token not found from arguments nor from .edicy file'.red
    end

    # host and token are provided and config file doesn't exist
    if (host && @config[:host].nil?) && (api_token && @config[:api_token].nil?)
      Edicy::Dtk.write_config(host, api_token, silent)
    # host and token are provided and config file already exists
    elsif (host && !@config[:host].nil? && host != @config[:host]) || (api_token && !@config[:api_token].nil? && api_token != @config[:api_token])
      Edicy::Dtk.write_config(host, api_token, silent)
    end
  end
  client = Edicy::Client.new(host, api_token)
  @filemanager = Edicy::Dtk::FileManager.new(client, verbose, silent)
end

on_error do |exception|
  puts exception
  # return false to skip default error handling
  false
end

exit run(ARGV)
