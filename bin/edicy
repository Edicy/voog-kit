#!/usr/bin/env ruby

# TODO: Not needed after bundled as gem
gem 'liquid'
gem 'guard'
require 'gli'

$LOAD_PATH << File.expand_path('../lib', File.dirname(__FILE__))
require 'json'

require 'edicy/dtk'
require 'edicy/dtk/guard'
require 'edicy/dtk/renderer'
require 'edicy/dtk/filemanager'
require 'edicy_api'

include GLI::App

program_desc 'A tool to fetch and update Edicy design components'

version Edicy::Dtk::VERSION

desc 'Show additional information while running'
switch [:verbose], negatable: false, default_value: false

desc 'Hide all information text while running'
switch [:silent], negatable: false, default_value: false

desc 'Provide a site URL'
arg_name :SITE_URL
flag [:h, :host]

desc 'Provide an API token'
arg_name :API_TOKEN
flag [:t, :token]

desc 'Initializes the local folder structure and files for a site'
long_desc "The init command takes a site url and an api token
          as arguments, fetches the structure of the site and
          recreates it locally in the same folder the command
          was evoked in.\n
          If the site-url and/or api-token isn't provided, the tool
          looks for a .edicy file to get the site url and then looks
          for a .edicy file in your $HOME folder to get the api
          token."
command :init do |c|
  c.switch [:verbose], negatable: false, default_value: false
  c.switch [:silent], default_value: false, negatable: true
  c.action do |global_options, options, args|
    @filemanager.copy_site_json
    @filemanager.create_folders
    @filemanager.create_files
  end

  c.command :new do |n|
    n.action do |n|
      @filemanager.copy_site_json
      @filemanager.fetch_boilerplate
    end
  end
end

desc 'Looks for missing files and folders'
command :check do |c|
  c.switch [:verbose], negatable: false, default_value: false
  c.switch [:silent], default_value: false, negatable: true
  c.action do |global_options, options, args|
    @filemanager.check
  end
end

desc 'Fetches the layout and layout asset files for the given site'
command :pull do |c|
  c.switch [:verbose], negatable: false, default_value: false
  c.switch [:silent], default_value: false, negatable: true
  c.action do |global_options, options, args|
    @filemanager.create_folders
    @filemanager.create_files
    @filemanager.generate_remote_manifest
  end
end

desc 'Updates remote files with local changes'
command :push do |c|
  c.switch [:verbose], negatable: false, default_value: false
  c.switch [:silent], default_value: false, negatable: true
  c.action do |global_options, options, args|
    @filemanager.upload_files args
  end
end

desc "Generates a manifest.json file from the site's layout and asset files"
command :manifest do |c|
  c.switch [:verbose], negatable: false, default_value: false
  c.switch [:silent], default_value: false, negatable: true
  c.switch(
    [:r, :remote],
    default_value: false,
    desc: 'generate manifest from remote files'
  )
  c.action do |global_options, options, args|
    if options.fetch(:remote, false)
      @filemanager.generate_remote_manifest
    else
      @filemanager.generate_local_manifest
    end
  end
end

desc 'Watches for file changes in the current directory'
command :watch do |c|
  c.switch [:verbose], negatable: false, default_value: false
  c.switch [:silent], default_value: false, negatable: true
  c.switch(
    [:e, :editmode],
    negatable: false,
    desc: "Specify if editmode should be considered \
          enabled for the purpose of rendering (default: false)"
  )
  c.action do |global_options, options, args|
    output_folder = args.first || 'html'
    @renderer = Edicy::Dtk::Renderer.new(Dir.pwd, output_folder)
    @renderer.editmode = options.fetch(:editmode) || @editmode

    Edicy::Dtk::Guuard.new(@renderer, @filemanager).run
    sleep 0.5 while ::Guard.running
  end
end

desc 'Renders all pages into static .html files that are usable locally'
arg_name 'Describe arguments to build here'
command :build do |c|
  c.switch [:verbose], negatable: false, default_value: false
  c.switch [:silent], default_value: false, negatable: true
  c.switch(
    [:e, :editmode],
    negatable: false,
    desc: 'Specify if editmode should be considered \
    enabled for the purpose of rendering (default: false)'
  )
  c.action do |global_options, options, args|
    output_folder = args.first || 'html'
    @renderer = Edicy::Dtk::Renderer.new(Dir.pwd, output_folder)
    @renderer.editmode = options.fetch(:editmode) || @editmode
    @renderer.render_all
  end
end

pre do |global, command, options, args|
  @config = Edicy::Dtk.read_config '.edicy'
  @editmode = @config[:editmode]

  silent = global.fetch(:silent, false) || options.fetch(:silent, false)
  verbose = global.fetch(:verbose, false) || options.fetch(:verbose, false)

  unless ([:watch, :build, :new].include? command.name)
    site_url = global.fetch(:host) || @config[:site_url]
    api_token = global.fetch(:token) || @config[:api_token]

    if site_url.nil?
      fail 'Site URL not found from arguments nor from .edicy file'.red
    end

    if api_token.nil?
      fail 'API token not found from arguments nor from .edicy file'.red
    end
  end
  client = Edicy::Client.new(site_url, api_token)
  @filemanager = Edicy::Dtk::FileManager.new(client, verbose, silent)
end

on_error do |exception|
  # return false to skip default error handling
  true
end

exit run(ARGV)
